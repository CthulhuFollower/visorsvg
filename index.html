<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Visor SVG – GitHub Repo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {height:100%;margin:0;background:#fff;}
    #stage {position:fixed;inset:0;display:grid;place-items:center;touch-action:none;}
    #stage > svg {width:100vw;height:100vh;display:block;}
    #ui {
      position:fixed;top:1rem;left:1rem;z-index:10;
      background:rgba(255,255,255,.9);backdrop-filter:blur(8px);
      border:1px solid #e2e8f0;border-radius:.75rem;
      padding:.5rem .75rem;font:14px system-ui,sans-serif;
      display:flex;gap:.5rem;align-items:center;
    }
    select {font:inherit;padding:.25rem .5rem;}
    #msg {position:fixed;bottom:1rem;left:1rem;opacity:.6;font:12px system-ui;}
  </style>
</head>
<body>
  <div id="ui">
    <label for="fileSelect">SVG:</label>
    <select id="fileSelect"><option>Cargando…</option></select>
  </div>
  <div id="stage"></div>
  <div id="msg">Zoom: rueda/pinch · Pan: arrastrar · Doble clic: reset</div>

  <script>
    // ✅ TU REPO
    const GITHUB_USER = "CthulhuFollower";
    const GITHUB_REPO = "visorsvg";
    const SVG_PATH    = "svg";      // carpeta con tus .svg
    const BRANCH      = "main";

    const API = `https://api.github.com/repos/${GITHUB_USER}/${GITHUB_REPO}/contents/${SVG_PATH}?ref=${BRANCH}`;
    const CDN = `https://raw.githubusercontent.com/${GITHUB_USER}/${GITHUB_REPO}/${BRANCH}/${SVG_PATH}/`;

    const stage  = document.getElementById('stage');
    const select = document.getElementById('fileSelect');

    let svg, initialVB, currentVB;
    const MIN_ZOOM = 0.05, MAX_ZOOM = 50;

    function getVB(el){ const v=el.viewBox.baseVal; return [v.x,v.y,v.width,v.height]; }
    function setVB(el,vb){ el.setAttribute('viewBox',vb.join(' ')); }
    function ensureViewBox(el){
      if(!el.hasAttribute('viewBox')){
        const b=el.getBBox();
        el.setAttribute('viewBox',[b.x,b.y,b.width,b.height].join(' '));
      }
      el.setAttribute('preserveAspectRatio','xMidYMid meet');
    }

    async function loadInlineSVG(url){
      const res = await fetch(url + `?cacheBust=${Date.now()}`);
      if(!res.ok) throw new Error(`HTTP ${res.status} al cargar SVG`);
      const text = await res.text();
      stage.innerHTML = text.trim();
      svg = stage.querySelector('svg');
      if(!svg){ stage.innerHTML = '<p>No se encontró &lt;svg&gt;.</p>'; return; }
      ensureViewBox(svg);
      initialVB = getVB(svg);
      currentVB = [...initialVB];
      wireInteractions();
    }

    // --- Zoom y pan (viewBox) ---
    function zoomBy(factor, aroundCenter=true, clientX=null, clientY=null){
      if(!svg) return;
      const [x,y,w,h] = currentVB;
      const initScale = initialVB[2]/w;
      const nextScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, initScale*factor));
      const realFactor = nextScale/initScale;

      let cx,cy;
      if(aroundCenter || clientX==null){ cx = x+w/2; cy = y+h/2; }
      else{
        const pt = svg.createSVGPoint(); pt.x=clientX; pt.y=clientY;
        const sp = pt.matrixTransform(svg.getScreenCTM().inverse());
        cx = sp.x; cy = sp.y;
      }

      const newW = w/realFactor, newH = h/realFactor;
      const nx = cx - ((cx-x)/realFactor);
      const ny = cy - ((cy-y)/realFactor);
      currentVB = [nx,ny,newW,newH];
      setVB(svg,currentVB);
    }
    function resetZoom(){ currentVB = [...initialVB]; setVB(svg,currentVB); }

    function wireInteractions(){
      stage.onwheel = e => {
        e.preventDefault();
        const step=1.12;
        const factor = (e.deltaY<0) ? step : 1/step;
        zoomBy(factor, true, e.clientX, e.clientY);
      };
      stage.ondblclick = () => resetZoom();

      let panning=false, last=null;
      stage.onmousedown = e => { panning=true; last={x:e.clientX, y:e.clientY}; };
      window.onmouseup = () => panning=false;
      window.onmousemove = e => {
        if(!panning || !svg) return;
        const dx=e.clientX-last.x, dy=e.clientY-last.y;
        last={x:e.clientX,y:e.clientY};
        const m=svg.getScreenCTM().inverse();
        const p1=svg.createSVGPoint(), p2=svg.createSVGPoint();
        p1.x=0;p1.y=0;p2.x=dx;p2.y=dy;
        const s1=p1.matrixTransform(m), s2=p2.matrixTransform(m);
        currentVB[0]-=(s2.x-s1.x);
        currentVB[1]-=(s2.y-s1.y);
        setVB(svg,currentVB);
      };
    }

    // --- Poblar lista desde la API de GitHub ---
    async function populateList(){
      try{
        const res = await fetch(API);
        const data = await res.json();

        if(!Array.isArray(data)){
          console.error('Respuesta API:', data);
          select.innerHTML = "<option>Error: ruta o rama inválida</option>";
          return;
        }

        const files = data.filter(f => f.type === "file" && f.name.toLowerCase().endsWith(".svg"));
        if(files.length === 0){
          select.innerHTML = "<option>No hay SVG en /svg</option>";
          return;
        }

        select.innerHTML = "";
        files.forEach(f=>{
          const opt=document.createElement("option");
          opt.value=f.name;
          opt.textContent=f.name;
          select.appendChild(opt);
        });

        // Carga inicial
        await loadInlineSVG(CDN + files[0].name);
      }catch(err){
        console.error(err);
        select.innerHTML = "<option>Error al cargar la lista</option>";
      }
    }

    select.addEventListener("change", ()=>{
      const file = select.value;
      if(file) loadInlineSVG(CDN + file);
    });

    populateList();
  </script>
</body>
</html>
